<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Katalog produkt√≥w (Flipbook + zoom scroll)</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:0;background:#f5f6f8;color:#111}
  header{padding:12px 14px;text-align:center;background:#fff;border-bottom:1px solid #eceff1}
  h1{margin:0;font-size:20px}
  #wrap{max-width:1400px;margin:8px auto;padding:10px}
  /* The flipbook container is responsive via CSS (width calc + max-width).
     We rely on restoring computed px sizes after fullscreen to avoid leftover 100vw/100vh inline styles. */
  #flipbook{margin:10px auto;width:calc(100% - 40px);max-width:1300px;background:#fff;border:1px solid #e6e9ee;position:relative;overflow:hidden;box-shadow:0 6px 20px rgba(0,0,0,0.06)}
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center;margin:8px 0}
  button{padding:8px 12px;border-radius:8px;border:none;background:#1976d2;color:#fff;cursor:pointer}
  button.secondary{background:#6b7280}
  button:disabled{opacity:.55;cursor:not-allowed}
  .page-info{margin-left:8px;color:#333}
  @media (max-width:700px){ #flipbook{width:calc(100% - 24px);} }
  #flipbook img {width:100%;height:auto;max-width:100%;object-fit:contain;display:block;margin:0 auto;}
  /* Modal zoom */
  .zoom-modal {
    display:none;position:fixed;z-index:2000;left:0;top:0;width:100vw;height:100vh;
    background:rgba(0,0,0,0.89);justify-content:center;align-items:center;
    overflow:hidden;
  }
  .zoom-modal.active {display:flex;}
  .zoom-modal .close {
    position:absolute;top:24px;right:40px;font-size:38px;color:#fff;font-weight:900;cursor:pointer;z-index:10;
    background:rgba(0,0,0,0.22);border-radius:10px;width:46px;height:46px;display:flex;align-items:center;justify-content:center;
    transition:background 0.2s;
  }
  .zoom-modal .close:hover {background:rgba(0,0,0,0.5);}
  .zoom-img-wrap {
    position:relative;display:flex;align-items:center;justify-content:center;flex:1 1 0%;
    width:100vw;height:100vh;overflow:hidden;
    touch-action:none;
  }
  .zoom-img-wrap img {
    max-width:95vw; max-height:95vh; border-radius:10px; box-shadow:0 6px 24px rgba(0,0,0,0.25);
    background:#fff; display:block;
    cursor:grab;
    user-select:none;
    transition:box-shadow 0.2s;
    will-change: transform;
    position:relative;
  }
  .zoom-img-wrap img:active { cursor:grabbing; }
  .zoom-hint {
    position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
    background:rgba(0,0,0,0.55);color:#fff;padding:5px 16px;border-radius:8px;font-size:15px;
    z-index:20;pointer-events:none;
  }
</style>
<!-- StPageFlip -->
<script src="StPageFlip-2.0.0/page-flip.browser.min.js"></script>
</head>
<body>
<header><h1>Katalog produkt√≥w</h1></header>

<div id="wrap">
  <div id="flipbook" aria-live="polite"></div>

  <div class="controls" role="toolbar" aria-label="Kontrolki flipbook">
    <button id="prevBtn" class="secondary" disabled>‚óÄ Poprzednia</button>
    <button id="nextBtn" disabled>Nastƒôpna ‚ñ∂</button>
    <button id="fullBtn" disabled>Pe≈Çny ekran</button>
    <button id="zoomLeftBtn" disabled title="Zbli≈º lewƒÖ stronƒô">üîç Zbli≈º lewƒÖ</button>
    <button id="zoomRightBtn" disabled title="Zbli≈º prawƒÖ stronƒô">üîç Zbli≈º prawƒÖ</button>
    <span class="page-info" id="pageInfo">≈Åadowanie‚Ä¶</span>
  </div>
</div>

<!-- Modal do zbli≈ºenia -->
<div class="zoom-modal" id="zoomModal">
  <span class="close" id="zoomClose">&times;</span>
  <div class="zoom-img-wrap" id="zoomImgWrap">
    <img id="zoomImg" src="" alt="Zbli≈ºona strona">
    <div class="zoom-hint" id="zoomHint">Przytrzymaj i przeciƒÖgnij, aby przesuwaƒá. U≈ºyj scrolla, aby powiƒôkszaƒá.</div>
  </div>
</div>

<script>
const NUM_PAGES = 19;
const FILE_BASE = '/pages/twoj_plik1-';
const FILE_EXT = '.png';

function getPagesArray() {
  const arr = [];
  for(let i=1;i<=NUM_PAGES;i++) {
    const num = i.toString().padStart(2,'0');
    arr.push(FILE_BASE + num + FILE_EXT);
  }
  return arr;
}

const container = document.getElementById('flipbook');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const fullBtn = document.getElementById('fullBtn');
const zoomLeftBtn = document.getElementById('zoomLeftBtn');
const zoomRightBtn = document.getElementById('zoomRightBtn');
const pageInfo = document.getElementById('pageInfo');
const zoomModal = document.getElementById('zoomModal');
const zoomImgWrap = document.getElementById('zoomImgWrap');
const zoomImg = document.getElementById('zoomImg');
const zoomClose = document.getElementById('zoomClose');
const zoomHint = document.getElementById('zoomHint');

let flipbook = null;

// snapshot storage
let snapshot = {
  inlineCssText: '',
  computedWidth: null,
  computedHeight: null,
  parentWidth: null,
  bodyOverflow: ''
};
let usingManualFs = false;

function setContainerHeight(){
  const headerH = document.querySelector('header').offsetHeight || 0;
  const controlsH = document.querySelector('.controls').offsetHeight || 0;
  const margin = 18;
  const available = Math.max(200, window.innerHeight - headerH - controlsH - margin);
  // Only set height for responsive layout; width remains controlled by CSS (calc(...) and max-width)
  container.style.height = available + 'px';
}

// Save current inline cssText + computed px sizes (before entering fullscreen)
function saveSnapshot() {
  snapshot.inlineCssText = container.style.cssText || '';
  const rect = container.getBoundingClientRect();
  snapshot.computedWidth = Math.round(rect.width);
  snapshot.computedHeight = Math.round(rect.height);
  snapshot.parentWidth = container.parentElement ? Math.round(container.parentElement.getBoundingClientRect().width) : null;
  snapshot.bodyOverflow = document.body.style.overflow || '';
  console.debug('[flipbook] snapshot saved', snapshot);
}

// Restore exact computed px size first, then let flipbook update, then restore original inline cssText (so CSS rules resume)
function restoreAfterFullscreenExit() {
  // If snapshot not saved, fallback to recalculation
  if (!snapshot.computedWidth || !snapshot.computedHeight) {
    // fallback: just recalc with setContainerHeight and update flipbook
    setContainerHeight();
    if (flipbook && typeof flipbook.update === 'function') flipbook.update();
    return;
  }

  // apply temporary inline px to match pre-fullscreen rendering
  container.style.width = snapshot.computedWidth + 'px';
  container.style.height = snapshot.computedHeight + 'px';
  // keep any position/zIndex from previous inline snapshot (we restore full cssText later)
  // force reflow
  void container.offsetWidth;
  // update flipbook so it recalculates to temporary size
  if (flipbook && typeof flipbook.update === 'function') flipbook.update();

  // after flipbook updates, restore original inline cssText (may be empty) to resume responsive behavior
  setTimeout(() => {
    container.style.cssText = snapshot.inlineCssText;
    document.body.style.overflow = snapshot.bodyOverflow;
    // small delay then update again to ensure layout is consistent
    setTimeout(() => {
      if (flipbook && typeof flipbook.update === 'function') flipbook.update();
      console.debug('[flipbook] restored original inline cssText and updated');
    }, 180);
  }, 120);
}

// Fallback manual fullscreen (when Fullscreen API isn't available)
function applyManualFullscreen() {
  usingManualFs = true;
  // Save snapshot before applying manual fullscreen
  saveSnapshot();
  container.style.position = 'fixed';
  container.style.top = '0';
  container.style.left = '0';
  container.style.width = '100vw';
  container.style.height = '100vh';
  container.style.zIndex = '9999';
  document.body.style.overflow = 'hidden';
  if (flipbook && typeof flipbook.update === 'function') flipbook.update();
}

// Toggle fullscreen: native if supported, otherwise manual fallback
function toggleFull() {
  const isInFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
  if (!isInFs && !usingManualFs) {
    saveSnapshot();
    if (container.requestFullscreen) {
      container.requestFullscreen({ navigationUI: 'hide' }).catch(()=>{});
    } else if (container.webkitRequestFullscreen) {
      container.webkitRequestFullscreen({ navigationUI: 'hide' });
    } else {
      applyManualFullscreen();
    }
  } else {
    // if using manual fallback, exit manual mode
    if (usingManualFs) {
      usingManualFs = false;
      restoreAfterFullscreenExit();
      return;
    }
    if (document.exitFullscreen) {
      document.exitFullscreen().catch(()=>{});
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else {
      // nothing else to do
    }
  }
}

function debounce(fn,wait){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }

function updatePageInfo() {
  if(!flipbook) return;
  let cur = 0, total = NUM_PAGES;
  try {
    if (typeof flipbook.getCurrentPageIndex === 'function') {
      cur = flipbook.getCurrentPageIndex();
    } else if (typeof flipbook.getCurrentPageIndex === 'number') {
      cur = flipbook.getCurrentPageIndex;
    }
  } catch(e) { cur = 0; }
  pageInfo.innerText = `Strona ${cur+1} / ${total}`;
}

function showZoomModal(pageIndex) {
  const pages = getPagesArray();
  if(pageIndex < 0 || pageIndex >= pages.length) return;
  zoomImg.src = pages[pageIndex];
  zoomModal.classList.add('active');
  document.body.style.overflow = 'hidden';
  setTimeout(() => setupImgZoom(), 100);
}
function hideZoomModal() {
  zoomModal.classList.remove('active');
  zoomImg.src = '';
  document.body.style.overflow = '';
  removeImgZoom();
}

// --- Zoom logic (unchanged) ---
let zoom = 1, minZoom = 1, maxZoom = 6, panX = 0, panY = 0, isPanning = false, startX = 0, startY = 0;
function setupImgZoom() {
  zoom = 1; panX = 0; panY = 0;
  applyImgTransform();
  zoomImg.style.cursor = 'grab';

  zoomImg.onwheel = function(e) {
    e.preventDefault();
    let rect = zoomImg.getBoundingClientRect();
    let mouseX = e.clientX - rect.left;
    let mouseY = e.clientY - rect.top;
    let relX = (mouseX - panX) / zoom;
    let relY = (mouseY - panY) / zoom;
    let delta = e.deltaY < 0 ? 1.15 : 0.87;
    let newZoom = Math.max(minZoom, Math.min(maxZoom, zoom * delta));
    panX -= (relX * (newZoom - zoom));
    panY -= (relY * (newZoom - zoom));
    zoom = newZoom;
    applyImgTransform();
  };

  zoomImg.onmousedown = function(e) {
    if(zoom === 1) return;
    isPanning = true;
    startX = e.clientX - panX;
    startY = e.clientY - panY;
    zoomImg.style.cursor = 'grabbing';
    document.onmousemove = function(e) {
      if(!isPanning) return;
      panX = e.clientX - startX;
      panY = e.clientY - startY;
      applyImgTransform();
    };
    document.onmouseup = function() {
      isPanning = false;
      zoomImg.style.cursor = 'grab';
      document.onmousemove = null;
      document.onmouseup = null;
    };
  };
  zoomImg.ondblclick = function(e){
    if(zoom===1) {
      let rect = zoomImg.getBoundingClientRect();
      let mouseX = e.clientX - rect.left;
      let mouseY = e.clientY - rect.top;
      let relX = (mouseX - panX) / zoom;
      let relY = (mouseY - panY) / zoom;
      let newZoom = 2;
      panX -= (relX * (newZoom - zoom));
      panY -= (relY * (newZoom - zoom));
      zoom = newZoom;
    } else {
      zoom = 1; panX = 0; panY = 0;
    }
    applyImgTransform();
  };
  zoomImg.onmousemove = function(e) { if(zoom>1){zoomImg.style.cursor='grabbing';}else{zoomImg.style.cursor='grab';}};
  zoomImg.onmouseleave = function(e){ if(isPanning) {isPanning=false; zoomImg.style.cursor='grab'; document.onmousemove=null; document.onmouseup=null;}};
  zoomHint.style.opacity = 1;
  setTimeout(()=>{zoomHint.style.opacity=0;}, 5000);
}
function removeImgZoom() {
  zoomImg.onwheel = null;
  zoomImg.onmousedown = null;
  zoomImg.ondblclick = null;
  zoomImg.onmousemove = null;
  zoomImg.onmouseleave = null;
  zoomHint.style.opacity = 0;
}
function applyImgTransform() {
  zoomImg.style.transform = `translate(${panX}px,${panY}px) scale(${zoom})`;
}

async function init(){
  // initial sizing and snapshot of current responsive layout
  setContainerHeight();
  // save initial snapshot so we can restore to exact look after fullscreen
  saveSnapshot();

  const pages = getPagesArray();

  flipbook = new St.PageFlip(container, {
    width:900, height:1200,
    size:'stretch', autoSize:true,
    minWidth:300, maxWidth:2000, minHeight:300, maxHeight:3000,
    showCover:false, usePortrait:true, maxShadowOpacity:0.6, mobileScrollSupport:true
  });
  flipbook.loadFromImages(pages);

  prevBtn.disabled=false; nextBtn.disabled=false; fullBtn.disabled=false; zoomLeftBtn.disabled=false; zoomRightBtn.disabled=false;
  prevBtn.onclick = () => { if (flipbook && typeof flipbook.turnToPrevPage === 'function') flipbook.turnToPrevPage(); };
  nextBtn.onclick = () => { if (flipbook && typeof flipbook.turnToNextPage === 'function') flipbook.turnToNextPage(); };
  fullBtn.onclick = toggleFull;

  document.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowRight') { if (flipbook && typeof flipbook.turnToNextPage === 'function') flipbook.turnToNextPage(); }
    if(e.key==='ArrowLeft')  { if (flipbook && typeof flipbook.turnToPrevPage === 'function') flipbook.turnToPrevPage(); }
    if(zoomModal.classList.contains('active') && e.key==='Escape') hideZoomModal();
  });

  zoomLeftBtn.onclick = () => {
    if(!flipbook) return;
    let idx = (typeof flipbook.getCurrentPageIndex === 'function') ? flipbook.getCurrentPageIndex() : 0;
    showZoomModal(idx);
  };
  zoomRightBtn.onclick = () => {
    if(!flipbook) return;
    let idx = (typeof flipbook.getCurrentPageIndex === 'function') ? flipbook.getCurrentPageIndex() : 0;
    showZoomModal(idx+1);
  };

  zoomClose.onclick = hideZoomModal;
  zoomModal.onclick = (e) => { if(e.target === zoomModal) hideZoomModal(); };
  zoomImg.onclick = (e) => { if(zoom===1) hideZoomModal(); };

  flipbook.on('flip', updatePageInfo);
  flipbook.on('init', updatePageInfo);
  setTimeout(updatePageInfo, 500);

  const onResize = debounce(()=>{
    setContainerHeight();
    if(typeof flipbook.update === 'function') flipbook.update();

    // update computed snapshot when user resizes normally (not while in fullscreen)
    if(!document.fullscreenElement && !document.webkitFullscreenElement && !usingManualFs) {
      const rect = container.getBoundingClientRect();
      snapshot.computedWidth = Math.round(rect.width);
      snapshot.computedHeight = Math.round(rect.height);
      snapshot.parentWidth = container.parentElement ? Math.round(container.parentElement.getBoundingClientRect().width) : null;
      console.debug('[flipbook] snapshot updated on resize', snapshot);
    }
  },220);
  window.addEventListener('resize',onResize);

  // Listen native fullscreen changes
  function onFsChange() {
    const inFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
    if (!inFs) {
      // exited native fullscreen: restore exact px size then update and finally clear inline to resume CSS
      console.debug('[flipbook] exited fullscreen, restoring sizes');
      restoreAfterFullscreenExit();
    } else {
      console.debug('[flipbook] entered fullscreen');
    }
  }
  document.addEventListener('fullscreenchange', onFsChange);
  document.addEventListener('webkitfullscreenchange', onFsChange);
}

window.addEventListener('load',init);
</script>
</body>
</html>
