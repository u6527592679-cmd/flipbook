<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Katalog produktów — szybkie renderowanie</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:0;background:#f5f6f8;color:#111}
    header{padding:12px 14px;text-align:center;background:#fff;border-bottom:1px solid #eceff1}
    h1{margin:0;font-size:20px}
    #wrap{max-width:1400px;margin:8px auto;padding:10px}
    #flipbook{margin:10px auto;width:calc(100% - 40px);max-width:1300px;background:#fff;border:1px solid #e6e9ee;position:relative;overflow:hidden;box-shadow:0 6px 20px rgba(0,0,0,0.06)}
    .loader{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,0.95);padding:10px 14px;border-radius:8px;z-index:1500;box-shadow:0 6px 18px rgba(0,0,0,0.08);font-weight:600}
    .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center;margin:8px 0}
    button{padding:8px 12px;border-radius:8px;border:none;background:#1976d2;color:#fff;cursor:pointer}
    button.secondary{background:#6b7280}
    button:disabled{opacity:.55;cursor:not-allowed}
    .page-info{margin-left:8px;color:#333}
    @media (max-width:700px){ #flipbook{width:calc(100% - 24px);} }
  </style>

  <!-- PDF.js -->
  <script src="pdfjs/pdf.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdfjs/pdf.worker.js';</script>
  <!-- StPageFlip -->
  <script src="StPageFlip-2.0.0/page-flip.browser.min.js"></script>
</head>
<body>
  <header><h1>Katalog produktów — szybkie</h1></header>

  <div id="wrap">
    <div id="flipbook" aria-live="polite"></div>

    <div class="controls" role="toolbar" aria-label="Kontrolki flipbook">
      <button id="prevBtn" class="secondary" disabled>◀ Poprzednia</button>
      <button id="nextBtn" disabled>Następna ▶</button>
      <button id="fullBtn" disabled>Pełny ekran</button>
      <span class="page-info" id="pageInfo">Ładowanie…</span>
      <a href="twoj_plik.pdf" download style="margin-left:12px;color:#1976d2;font-weight:600">Pobierz PDF</a>
    </div>
  </div>

<script>
/* ========== USTAWIENIA ========== */
const PDF_URL = 'twoj_plik.pdf';
const DPR = Math.max(1, window.devicePixelRatio || 1);
/* MAX_CANVAS_DIM zabezpiecza przed tworzeniem zbyt dużego canvasa */
const MAX_CANVAS_DIM = 14000;
/* ================================= */

pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdfjs/pdf.worker.js';

const container = document.getElementById('flipbook');
const loader = document.createElement('div'); loader.className='loader'; loader.innerText='Przygotowywanie...'; container.appendChild(loader);

const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const fullBtn = document.getElementById('fullBtn');
const pageInfo = document.getElementById('pageInfo');

let pdfDoc = null;
let flipbook = null;
let pagesData = [];
let pagesCache = {}; // cache [index] -> dataURL

/* placeholder tiny */
function makePlaceholder(){ const c=document.createElement('canvas'); c.width=4; c.height=4; const ctx=c.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,4,4); return c.toDataURL(); }

/* dynamic container height to fill viewport (minus header and controls) */
function setContainerHeight(){
  const headerH = document.querySelector('header').offsetHeight || 0;
  const controlsH = document.querySelector('.controls').offsetHeight || 0;
  const margin = 18;
  const available = Math.max(200, window.innerHeight - headerH - controlsH - margin);
  container.style.height = available + 'px';
}

/* compute fit scale so page covers container (no hi-res multipliers) */
async function computeFitScale(pageNumber, mode='cover'){
  const page = await pdfDoc.getPage(pageNumber);
  const vp = page.getViewport({ scale: 1 });
  const targetW = container.clientWidth * DPR;
  const targetH = container.clientHeight * DPR;
  const sx = targetW / vp.width;
  const sy = targetH / vp.height;
  return (mode === 'cover') ? Math.max(sx, sy) : Math.min(sx, sy);
}

/* render page to image at fit scale (fast-ish). Protect against too big canvases. */
async function renderPageToDataUrl(pageNumber, scale){
  // guard predicted dimensions
  const page = await pdfDoc.getPage(pageNumber);
  const base = page.getViewport({ scale: 1 });
  let predictedW = Math.round(base.width * scale);
  let predictedH = Math.round(base.height * scale);
  if (predictedW > MAX_CANVAS_DIM || predictedH > MAX_CANVAS_DIM) {
    const reduce = Math.min(MAX_CANVAS_DIM / predictedW, MAX_CANVAS_DIM / predictedH);
    scale = scale * reduce;
    predictedW = Math.round(base.width * scale);
    predictedH = Math.round(base.height * scale);
    console.warn('Scale reduced to avoid huge canvas for page', pageNumber, 'new scale', scale.toFixed(2));
  }
  const viewport = page.getViewport({ scale });
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  canvas.width = Math.round(viewport.width);
  canvas.height = Math.round(viewport.height);
  await page.render({ canvasContext: ctx, viewport }).promise;
  return canvas.toDataURL('image/jpeg', 0.9);
}

/* apply images array -> flipbook (safe methods) */
function applyImages(images) {
  try {
    if (!flipbook) return;
    if (typeof flipbook.updateFromImages === 'function') {
      flipbook.updateFromImages(images);
      return;
    }
    if (typeof flipbook.loadFromImages === 'function') {
      flipbook.loadFromImages(images);
      return;
    }
    // fallback: replace <img> if present
    const imgs = container.querySelectorAll('img');
    for (let i=0;i<images.length && i<imgs.length;i++) imgs[i].src = images[i];
  } catch(e){ console.error(e); }
}

/* ensure page is rendered (only fit scale). Also optionally preload neighbors. */
async function ensurePage(indexZeroBased) {
  if (pagesCache[indexZeroBased]) {
    pagesData[indexZeroBased] = pagesCache[indexZeroBased];
    applyImages(pagesData);
    return;
  }
  const pageNum = indexZeroBased + 1;
  const scale = await computeFitScale(pageNum, 'cover');
  const dataUrl = await renderPageToDataUrl(pageNum, scale);
  pagesCache[indexZeroBased] = dataUrl;
  pagesData[indexZeroBased] = dataUrl;
  applyImages(pagesData);
}

/* navigation helpers */
function nextPage(){
  if (!flipbook) return;
  if (typeof flipbook.flipNext === 'function') { try { flipbook.flipNext(); return; } catch(e){} }
  if (typeof flipbook.turnToNextPage === 'function') flipbook.turnToNextPage();
}
function prevPage(){
  if (!flipbook) return;
  if (typeof flipbook.flipPrev === 'function') { try { flipbook.flipPrev(); return; } catch(e){} }
  if (typeof flipbook.turnToPrevPage === 'function') flipbook.turnToPrevPage();
}

/* fullscreen toggle */
function toggleFull(){ if (!document.fullscreenElement) container.requestFullscreen?.() || container.webkitRequestFullscreen?.(); else document.exitFullscreen?.(); }

/* debounce helper */
function debounce(fn, wait){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }

/* ========== init ========== */
async function init(){
  try{
    setContainerHeight();
    const loadingTask = pdfjsLib.getDocument(PDF_URL);
    pdfDoc = await loadingTask.promise;
    const numPages = pdfDoc.numPages;
    pageInfo.innerText = `Strona 0 / ${numPages}`;
    loader.innerText = `Przygotowywanie dokumentu — ${numPages} stron`;

    // placeholders
    const placeholder = makePlaceholder();
    pagesData = new Array(numPages).fill(placeholder);

    // init flipbook
    flipbook = new St.PageFlip(container, {
      width: 900, height: 1100,
      size: 'stretch', autoSize: true,
      minWidth: 300, maxWidth: 2000, minHeight: 300, maxHeight: 3000,
      showCover: false, usePortrait: true, maxShadowOpacity: 0.6, mobileScrollSupport: true
    });
    flipbook.loadFromImages(pagesData);

    // controls
    prevBtn.disabled=false; nextBtn.disabled=false; fullBtn.disabled=false;
    prevBtn.onclick = prevPage; nextBtn.onclick = nextPage; fullBtn.onclick = toggleFull;
    document.addEventListener('keydown', (e)=>{ if(e.key==='ArrowRight') nextPage(); if(e.key==='ArrowLeft') prevPage(); });

    if (typeof flipbook.on === 'function') {
      flipbook.on('flip', async (e)=> {
        const idx = e.data;
        pageInfo.innerText = `Strona ${idx+1} / ${numPages}`;
        // render current page (fit) + preload neighbors
        loader.style.display='block';
        loader.innerText = `Wczytywanie strony ${idx+1}...`;
        await ensurePage(idx);
        // preload prev & next quickly (no heavy parallelism)
        if (idx-1 >= 0 && !pagesCache[idx-1]) { ensurePage(idx-1).catch(()=>{}); }
        if (idx+1 < numPages && !pagesCache[idx+1]) { ensurePage(idx+1).catch(()=>{}); }
        loader.style.display='none';
      });
    }

    // render first visible pages (0 and 1)
    loader.innerText = 'Wczytywanie pierwszych stron...';
    await ensurePage(0);
    if (numPages >= 2) await ensurePage(1);
    loader.style.display='none';
    const cur = (typeof flipbook.getCurrentPageIndex === 'function') ? flipbook.getCurrentPageIndex() : 0;
    pageInfo.innerText = `Strona ${cur+1} / ${numPages}`;

    // on resize: adjust container and re-render current page only
    const onResize = debounce(async ()=>{
      setContainerHeight();
      const curIdx = (typeof flipbook.getCurrentPageIndex === 'function') ? flipbook.getCurrentPageIndex() : 0;
      // clear cache for current page so we re-render in new fit size
      delet
